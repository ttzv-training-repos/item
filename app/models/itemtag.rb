class Itemtag < ApplicationRecord
  has_many :template_taggings, dependent: :destroy
  has_many :templates, through: :template_taggings

  def associate_with(template_id)
    TemplateTagging.upsert(template_id: template_id, itemtag_id: self.id)
  end

  def self.create_from_tag_string(tag_string)
    p tag_string
    Itemtag.create(
      name: tag_string,
      display_name: Parsers::ItemtagParser.tag_display_name(tag_string),
      description: "This tag was autogenerated"
    )
  end

  #if template_id provided applies custom mask instead
  def apply_mask(user_id, template_id=nil)
    if template_id
      tag_mask = TemplateTagging.find_by(
        template_id: template_id,
        itemtag_id: self.id
      )
      return "" if tag_mask.tag_custom_mask.nil?
      tag_mask = tag_mask.tag_custom_mask.value
    else
      tag_mask = self.default_value_mask 
    end
    return "" if tag_mask.nil?
    return "" if tag_mask.empty?

    mask_hash = JSON.parse(tag_mask, symbolize_names: true)
    user = AdUser.find(user_id)

    tag_value = String.new
    mask_hash.each do |hash|
      table, attribute = hash[:attribute].split("#")
      init_val = user.get_attr(attribute, table).to_s
      methods = hash.keys - [:attribute]
      masked_tag = Parsers::MaskApplier.new(init_val)
        methods.each do |m|
          options = hash[m]
          masked_tag.send(m, options)
        end
      tag_value += masked_tag.text  
    end
    tag_value
  end

  def store?(template)
    tagging = TemplateTagging.find_by(
      template_id: template.id,
      itemtag_id: self.id
    )
    return false if tagging.nil?
    return false if tagging.tag_custom_mask.nil?
    self.store_value || tagging.tag_custom_mask.store_value
  end

end
